;; NFT bridge smart contract

(int, int, int) load_data() inline {
    var ds = get_data().begin_parse();
    return 
        (ds~load_uint(256),  ;; ed25519 public key
         ds~load_uint(8),    ;; is initialized
         ds~load_uint(256)    ;; action id
        );
}

() save_data(int public_key, int is_initialized, int action_id) impure inline {
    set_data(begin_cell()
        .store_uint(public_key, 256)
        .store_uint(is_initialized, 8)
        .store_uint(action_id, 256)
        .end_cell());
}

() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }

    int op = in_msg_body~load_uint(32);

    if (op == 0) { ;; setup contract
        var (_, is_initialized, _) = load_data();
        throw_if(34, is_initialized);

        var public_key = in_msg_body~load_uint(256);
        save_data(public_key, 1, 0);
        return ();
    }

    if (op == 1) { ;; validate transfer nft
        var (public_key, _, _) = load_data();

        cell msg_cell = in_msg_body~load_ref();
        slice msg_slice = msg_cell.begin_parse();
        var action_id = msg_slice~load_uint(32);
        var item_index = msg_slice~load_uint(64);
        var amount_to_collection = msg_slice~load_coins();
        var amount_to_item = msg_slice~load_coins();
        var this_address = msg_slice~load_msg_addr();
        var collection_address = msg_slice~load_msg_addr();
        cell nft_item_content = msg_slice~load_ref();

        cell signature_cell = in_msg_body~load_ref();
        slice signature_slice = signature_cell.begin_parse();

        throw_unless(35, check_signature(cell_hash(msg_cell), signature_slice, public_key));
        
        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(collection_address)
            .store_coins(amount_to_collection)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(1, 32) ;; OP deploy new nft
            .store_uint(0, 64) ;; query_id
            .store_uint(item_index, 64)
            .store_coins(amount_to_item)
            .store_ref(nft_item_content);
        send_raw_message(msg.end_cell(), 1);
        return ();
    }

    if (op == 2) {  ;; validate unfreeze nft
        var (public_key, _, _) = load_data();

        cell msg_cell = in_msg_body~load_ref();
        slice msg_slice = msg_cell.begin_parse();
        var action_id = msg_slice~load_uint(32);
        var amount = msg_slice~load_coins();
        ;; var this_address = msg_slice~load_msg_addr();
        var nft_item_address = msg_slice~load_msg_addr();
        var to = msg_slice~load_msg_addr();

        cell signature_cell = in_msg_body~load_ref();
        slice signature_slice = signature_cell.begin_parse();

        throw_unless(35, check_signature(cell_hash(msg_cell), signature_slice, public_key));
        
        ;; TODO: send message to nft_item_address
        var nft_msg = begin_cell()
            .store_uint(0x18, 6) 
            .store_slice(nft_item_address)
            .store_coins(50000000)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(op::transfer(), 32)
            .store_uint(0, 64)
            .store_slice(to) ;; new_owner_address
            .store_slice(to) ;; response_address
            .store_int(0, 1) ;; empty custom_payload
            .store_coins(0) ;; forward amount to new_owner_address
            .store_int(0, 1); ;; empty forward_payload

        send_raw_message(nft_msg.end_cell(), 1);
        return ();
    } 

    if (op == op::ownership_assigned()) { ;; freeze nft - receive msg from nft item
        var query_id = in_msg_body~load_uint(64);
        var old_owner_address = in_msg_body~load_msg_addr();

        var (public_key, is_initialized, stored_action_id) = load_data();
        save_data(public_key, is_initialized, stored_action_id + 1);
        return ();
    }

    if (op == op::excesses()) { ;; withdraw nft - receive msg from nft item
        var query_id = in_msg_body~load_uint(64);

        var (public_key, is_initialized, stored_action_id) = load_data();
        save_data(public_key, is_initialized, stored_action_id + 1);
        return ();
    }

    ;; if (op == 5) {  ;; withdraw fees
    ;;     ;; TODO: 
    ;;     return ();
    ;; }

    ;; if (op == 6) {  ;; change public key
    ;;     ;; TODO: 
    ;;     return ();
    ;; }

    throw(0xffff);
}

() recv_external(slice in_msg) impure {
}

;; Get methods

int get_public_key() method_id {
    var (public_key, _, _) = load_data();
    return public_key;
}

int is_initialized() method_id {
    var (_, is_initialized, _) = load_data();
    return is_initialized;
}

int get_action_id() method_id {
    var (_, _, action_id) = load_data();
    return action_id;
}
