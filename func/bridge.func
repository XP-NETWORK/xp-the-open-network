;; NFT bridge smart contract

() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    ;; if (in_msg_body.slice_empty?()) { ;; ignore empty messages
    ;;     return ();
    ;; }

    int op = in_msg_body~load_uint(32);

    if (op == 1) {
        ;; var ds = get_data().begin_parse();
        ;; var (stored_seqno, stored_subwallet, public_key) = (ds~load_uint(32), ds~load_uint(32), ds~load_uint(256));
        ;; ds.end_parse();

        var group_key = in_msg_body~load_uint(256);
        var signature = in_msg_body~load_bits(512);
        cell msg_hash_cell = in_msg_body~load_ref();
        slice msg_hash = msg_hash_cell.begin_parse();

        cell msg_cell = in_msg_body~load_ref();
        slice msg = msg_cell.begin_parse();

        ;; throw_unless(35, check_data_signature(msg_hash, signature, group_key));
        set_data(begin_cell()
            ;; .store_uint(stored_seqno + 1, 32)
            ;; .store_uint(stored_subwallet, 32)
            ;; .store_uint(public_key, 256)
            .store_uint(group_key, 256)
            .store_uint(string_hash(msg), 256)
            .store_int(check_data_signature(msg_hash, signature, group_key), 32)
            .end_cell());

        return ();
    }

    throw(0xffff);
}

() recv_external(slice in_msg) impure {
    ;; var signature = in_msg~load_bits(512);
    ;; var cs = in_msg;
    ;; var (subwallet_id, valid_until, msg_seqno) = (cs~load_uint(32), cs~load_uint(32), cs~load_uint(32));
    ;; throw_if(35, valid_until <= now());
    ;; var ds = get_data().begin_parse();
    ;; var (stored_seqno, stored_subwallet, public_key) = (ds~load_uint(32), ds~load_uint(32), ds~load_uint(256));
    ;; ds.end_parse();
    ;; throw_unless(33, msg_seqno == stored_seqno);
    ;; throw_unless(34, subwallet_id == stored_subwallet);
    ;; throw_unless(35, check_signature(slice_hash(in_msg), signature, public_key));
    ;; accept_message();
    ;; cs~touch();

    ;; while (cs.slice_refs()) {
    ;;     var mode = cs~load_uint(8);
    ;;     send_raw_message(cs~load_ref(), mode);
    ;; }

    ;; set_data(begin_cell()
    ;;     .store_uint(stored_seqno + 1, 32)
    ;;     .store_uint(stored_subwallet, 32)
    ;;     .store_uint(public_key, 256)
    ;;     .end_cell());
}

;; Get methods

;; int seqno() method_id {
;;     return get_data().begin_parse().preload_uint(32);
;; }

;; int get_public_key() method_id {
;;     var cs = get_data().begin_parse();
;;     cs~load_uint(64);
;;     return cs.preload_uint(256);
;; }

;; int get_subwallet_id() method_id {
;;     return get_data().begin_parse().skip_bits(32).preload_uint(32);
;; }

int get_group_key() method_id {
    return get_data().begin_parse().preload_uint(256);
}

int get_message_hash() method_id {
    return get_data().begin_parse().skip_bits(256).preload_uint(256);
}

int is_valid_sig() method_id {
    return get_data().begin_parse().skip_bits(512).preload_int(32);
}