;; NFT bridge smart contract

(int) load_data() inline {
    var ds = get_data().begin_parse();
    return (ds~load_uint(256));
}

() save_data(int public_key) impure inline {
    set_data(begin_cell()
        .store_uint(public_key, 256)
        .end_cell());
}

() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }

    int op = in_msg_body~load_uint(32);

    if (op == 0) { ;; setup contract
        var public_key = in_msg_body~load_uint(256);
        save_data(public_key);
        ;; var signature = in_msg_body~load_bits(512);
        ;; cell msg_hash_cell = in_msg_body~load_ref();
        ;; slice msg_hash = msg_hash_cell.begin_parse();

        ;; cell msg_cell = in_msg_body~load_ref();
        ;; slice msg = msg_cell.begin_parse();

        ;; ;; throw_unless(35, check_data_signature(msg_hash, signature, group_key));
        ;; set_data(begin_cell()
        ;;     ;; .store_uint(stored_seqno + 1, 32)
        ;;     ;; .store_uint(stored_subwallet, 32)
        ;;     ;; .store_uint(public_key, 256)
        ;;     .store_uint(group_key, 256)
        ;;     .store_uint(string_hash(msg), 256)
        ;;     .store_int(check_data_signature(msg_hash, signature, group_key), 32)
        ;;     .end_cell());

        return ();
    }

    if (op == 1) {
        var (public_key) = load_data();

        cell mint_body_cell = in_msg_body~load_ref();

        cell msg_cell = in_msg_body~load_ref();
        ;; slice msg_slice = msg_cell.begin_parse();

        cell signature_cell = in_msg_body~load_ref();
        slice signature_slice = signature_cell.begin_parse();

        throw_unless(35, check_signature(cell_hash(msg_cell), signature_slice, public_key));
        ;; var nft_collection_address;
        ;; var msg = begin_cell()
        ;;     .store_uint(0x18, 6)
        ;;     .store_slice(nft_collection_address)
        ;;     .store_coins(in_msg_body~load_coins())
        ;;     .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        ;;     .store_slice(message_body);
        ;; send_raw_message(msg.end_cell(), 1);
        
        return ();
    }

    throw(0xffff);
}

() recv_external(slice in_msg) impure {
}

;; Get methods

int get_public_key() method_id {
    var (public_key) = load_data();
    return public_key;
}

cell get_storage() method_id {
    return get_data();
}
